---
title: "Following protocol for flowSOM implementation"
output: html_notebook
---

NOTE: *R version 4.5.0*. Also make sure [Rtools45](https://cran.r-project.org/bin/windows/Rtools/rtools45/rtools.html) is downloaded.

## STEP 0: DOWNLOADING PACKAGES (SKIP IF ALREADY DOWNLOADED)

Navigate towards Tools \> Install Packages and download the following packages:

1.  *ggplot2*
2.  *ggpubr*
3.  *pheatmap*
4.  *tidyr*
5.  *devtools*

Then go on to download *BioConductor* in the following way in order to download *FlowCore* correctly.

```{r}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

#The following initializes usage of Bioc devel
BiocManager::install(version='devel')
BiocManager::install("flowCore", force = TRUE)
BiocManager::install("flowAI")

#use devtools to download packages from github
devtools::install_github("saeyslab/PeacoQC", force=TRUE)
devtools::install_github("saeyslab/FlowSOM")
```

## STEP 1: READING IN .FCS FILES / .LMD FILES + STANDARDIZING OF NAMES ETC.

```{r}
library('flowCore') 
library('FlowSOM') 
library('ggplot2')
library('flowAI')
```

```{r}
knitr::opts_chunk$set(cache = TRUE, warning = FALSE, 
                      message = FALSE, cache.lazy = FALSE)
#initialise pathways
fcs_dir <- "D:/Internship/data/full dataset/"
cleaned_fcs_dir <- file.path(fcs_dir, "Cleaned_FCS")

if (!dir.exists(cleaned_fcs_dir)) {
  dir.create(cleaned_fcs_dir)}

original_ds <- list.files(path=fcs_dir, pattern= '\\.LMD$', full.names=FALSE)
patient_ids <- as.integer(sub(".*[^0-9](\\d+)\\s+tube.*", "\\1", original_ds))
patient_file_dict <- split(original_ds, patient_ids)

#select which patients you want to extract from? AML, MDS, healthy or fulldataset
#aml_patients = c(144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 196, 197, 198, 199, 201)

#mds_patients = c(103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 186, 187, 188, 189, 192, 195, 200, 202, 204, 205, 206, 207, 208, 209, 210, 211)

healthy_patients = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,49,50)

#full_dataset = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,49,50,103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 186, 187, 188, 189, 192, 195, 200, 202, 204, 205, 206, 207, 208, 209, 210, 211, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 196, 197, 198, 199, 201)

if (exists("aml_patients")) {
  fcs_files <- unlist(patient_file_dict[as.character(aml_patients)])
} else if (exists("mds_patients")) {
  fcs_files <- unlist(patient_file_dict[as.character(mds_patients)])
} else if (exists("healthy_patients")) {
  fcs_files <- unlist(patient_file_dict[as.character(healthy_patients)])
} else if (exists("full_dataset")) {
  fcs_files <- unlist(patient_file_dict[as.character(full_dataset)])
} else {
  stop("No patient group was defined.")
}

fcs_data_list <- list()

#read all .LMD files in folder and save them to fcs_data_list
for (i in 1:length(fcs_files)) {
  file_path <- file.path(fcs_dir, fcs_files[i])
  fcs_data_list[[i]] <- read.FCS(file_path, dataset=2)
}
```

```{r}
#inspect one file
ff <- fcs_data_list[[2]]
#keyword(ff)
colnames(ff)
```

During compensation it was seen that not all flowFrames had same column names. So to standardize, column names of the fluorochrome channels are standardized.

```{r}
#renaming columns
rename_common_channels <- function(ff) {
  standard_names <- c("FITC", "PE", "ECD", "PC5.5", "PC7", "APC", "A700", "A750", "HLA", "KO")
  
  old_names <- colnames(ff)
  new_names <- old_names
  
  fl_int_log <- paste0("FL", 1:10, " INT LOG")
  fl_dash_a <- paste0("FL", 1:10, "-A")
  
  for (i in seq_along(standard_names)) {
    match_name <- c(fl_int_log[i], fl_dash_a[i])
    matched_idx <- which(old_names %in% match_name)
    if (length(matched_idx) > 0) {
      new_names[matched_idx[1]] <- standard_names[i]
    }
  }
  
  colnames(ff@exprs) <- new_names
  colnames(ff) <- new_names
  return(ff)
}

renamed_fcs_list <- lapply(fcs_data_list, rename_common_channels)
```

```{r}
#saving renamed .fcs files
output_dir <- normalizePath("D:/Internship/data/full dataset with renamed columns", mustWork = FALSE)
dir.create(output_dir, showWarnings = FALSE)

clean_file_names <- paste0(tools::file_path_sans_ext(basename(fcs_files)), ".fcs")

if (length(clean_file_names) != length(renamed_fcs_list)) {
  stop("Length of fsc_files and renamed_fcs_list do not match!")
}

for (i in seq_along(renamed_fcs_list)) {
  ff <- renamed_fcs_list[[i]]
  
  if (!inherits(ff, "flowFrame")) {
    warning(paste("Skipping element", i, "â€” not a valid flowFrame"))
    next
  }
  
  file_name <- clean_file_names[i]
  full_path <- file.path(output_dir, file_name)
  
  cat("Saving:", full_path, "\n")
  write.FCS(ff, filename = full_path)
}

```

#### abbreviations used

FS INT LIN: forward scatter.

-   relates to the size of the cell

SS INT LIN: side scatter

-   reflects the complexity or granularity of the cell

TIME: duration of cell's passage through the laser beam

PEAK: is used to separate doublets from singlets.

## STEP 2: MANUAL COMPENSATION

Compensation can be done automatically or manually. For this, a **Spillover Spreading Matrix (SSM)** needs to be made. This matrix has been revealed to demonstrate fluorescence spectrum interactions. This compensation of flow cytometry data is essential as it corrects for the overlap of fluorescent signals between different channels.

NOTE: make sure compensation matrix is in fractions and NOT percentages!!

```{r}
library(readxl)

comp_matrix <- read_excel("D:/Internship/spillover_matrix.xlsx")

#Renaming row+columns and converting to num matrix.
comp_mat <- as.matrix(comp_matrix[, -c(1, 2)])
rownames(comp_mat) <- comp_matrix[[1]]
comp_mat <- comp_mat[-1, ]
comp_mat <- apply(comp_mat, 2, as.numeric)

fcs_data_list_comp <- lapply(renamed_fcs_list, function(ff) {
  compensate(ff, comp_mat)
})
```

```{r}

```

## STEP 3: QUALITY CHECK USING flowAI

flowAI is used to remove events having anomalous values when looking at three aspect of a flow cytometry analysis:

1.  **flow rate**: Checks whether cells are passin through the flow cytometer at an appropriate rate. Anomalies could be due to issues like clumping of cells, clogging or incorrect flow rate settings. A high percentages suggests that cells may be analyzed under suboptimal flow conditions.

    -   Uses *generalized ESD* to detect outliers (see .ppt for further elaboration

2.  **signal acquisition**: accounts for fluorescence and scatter signal of cells. Anomalies can arise due to inadequate staining, photobleaching etc. A substantial proportion of cells with anomalous signal acquisition can lead to inaccurate fluorescence intensity measurements, affecting the interpretation of the data.

    \- Uses *Binary Segmentation* to check for changepoints and remove instable regions

3.  **dynamic range**: Evaluates whether intensities of cells fall within detectable range of cytometer. Cells outside this range can either be too dim (below detection limit) or too bright (causing signal saturation), both of which can skew data interpretation.

    -   Filter out all measurements above hard upper limit and removes all negative scatter values. For fluorescent channels, it removed outliers of negative range.

several arguments can be changed within flow_auto_qc to improve quality control results. Moreover, remove_from can be used to perform partial quality control on only one or two of the above mentioned properties.

The suggestion is to run automatic method first with default settings, if results are not satisfying, we can modify arguments.

```{r}
warnings()

#loop through all .lmd files and perform quality control
for (i in 1:length(fcs_data_list_comp)) {
  proceed_flag <- TRUE

  flow_frame <- fcs_data_list_comp[[i]]
  tryCatch({
    cleaned_fcs_data <- flow_auto_qc(flow_frame)
  }, error = function(e) {
    cat("Error in flow_auto_qc: ", as.character(e$message), "\n")
    proceed_flag <- FALSE  # Set flag to not proceed
  })
  
  if (proceed_flag) {
    cleaned_file_name <- paste0("Cleaned_", fcs_files[i])
    cleaned_file_path <- file.path(cleaned_fcs_dir, cleaned_file_name)
  
    tryCatch({
      write.FCS(cleaned_fcs_data, cleaned_file_path)
    }, error = function(e) {
      cat("Error in write.FCS: ", as.character(e$message), "\n")
    })
    
    # Display a message to indicate progress
    cat("Saved cleaned FCS file to:", cleaned_file_path, "\n")
  }
}

```

## **STEP 4: TRANSFORMATION**

Compensation corrects for spectral overlap between different fluorochromes, but it doesn't address the issue of data distribution. Flow cytometry data often exhibits positively skewed distribution. Transformations like log or biexponential (logicle) are used to convert this skewed data into a more normally distributed form. Which type of scaling should I use?

```{r}

```

```{r}

```

`{c("SSC-A", "FITC-A", "PE-A", "PerCP-Cy5.5-A", "PE-Cy7-A", "APC-A", "APC-R700-A")}`

Here we perform the removal of margin events and also the compensation is done. - Compensation is done to correct for spillover - removal of margin events, because these

```{r}
channels_of_interest <- GetChannels(object = fcs1, markers = markers_of_interest, exact = FALSE)

ff_m <- PeacoQC::RemoveMargins(fcs1, markers_of_interest)
ff_c <- compensate(ff_m, spillover(fcs1)$`$SPILLOVER`) #spillover(fcs1) extracts the spillover matrix from the metadata of the file.
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
