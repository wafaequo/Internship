---
title: "Following protocol for flowSOM implementation"
output: html_notebook
---

NOTE: *R version 4.5.0*. Also make sure [Rtools45](https://cran.r-project.org/bin/windows/Rtools/rtools45/rtools.html) is downloaded.

## STEP 0.1: DOWNLOADING PACKAGES (SKIP IF ALREADY DOWNLOADED)

Navigate towards Tools \> Install Packages and download the following packages:

1.  *ggplot2*
2.  *ggpubr*
3.  *pheatmap*
4.  *tidyr*
5.  *devtools*

Then go on to download *BioConductor* in the following way in order to download *FlowCore* correctly.

```{r}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

#The following initializes usage of Bioc devel
BiocManager::install(version='devel')
BiocManager::install("flowCore", force = TRUE)
BiocManager::install("flowAI")
BiocManager::install("ggcyto")

#use devtools to download packages from github
devtools::install_github("saeyslab/PeacoQC", force=TRUE)
devtools::install_github("saeyslab/FlowSOM")
```

## STEP 0.2: READING IN .LMD FILES + NAME STANDARDIZATION

```{r}
library('flowCore') 
library('FlowSOM') 
library('ggplot2')
library('flowAI')
```

```{r}
knitr::opts_chunk$set(cache = TRUE, warning = FALSE, 
                      message = FALSE, cache.lazy = FALSE)
#initialise pathways
fcs_dir <- "D:/Internship/data/full dataset/"
cleaned_fcs_dir <- file.path(fcs_dir, "Cleaned_FCS")

if (!dir.exists(cleaned_fcs_dir)) {
  dir.create(cleaned_fcs_dir)}

original_ds <- list.files(path=fcs_dir, pattern= '\\.LMD$', full.names=FALSE)
patient_ids <- as.integer(sub(".*[^0-9](\\d+)\\s+tube.*", "\\1", original_ds))
patient_file_dict <- split(original_ds, patient_ids)

#select which patients you want to extract from? AML, MDS, healthy or fulldataset
aml_patients = c(144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 196, 197, 198, 199, 201)

#mds_patients = c(103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 186, 187, 188, 189, 192, 195, 200, 202, 204, 205, 206, 207, 208, 209, 210, 211)

#healthy_patients = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,49,50)

#full_dataset = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,49,50,103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 186, 187, 188, 189, 192, 195, 200, 202, 204, 205, 206, 207, 208, 209, 210, 211, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 196, 197, 198, 199, 201)

# Identify which patient group is selected
if (exists("aml_patients")) {
  selected_patients <- aml_patients
} else if (exists("mds_patients")) {
  selected_patients <- mds_patients
} else if (exists("healthy_patients")) {
  selected_patients <- healthy_patients
} else if (exists("full_dataset")) {
  selected_patients <- full_dataset
} else {
  stop("No patient group was defined.")
}

fcs_files <- unlist(patient_file_dict[as.character(selected_patients)])

fcs_data_list <- list()

#read all .LMD files in folder and save them to fcs_data_list
for (id in names(patient_file_dict)) {
  if (as.integer(id) %in% selected_patients) {
    file_names <- patient_file_dict[[id]]
    for (file in file_names) {
      file_path <- file.path(fcs_dir, file)
      key <- paste0("ID_", id, "_", tools::file_path_sans_ext(file))
      fcs_data_list[[key]] <- read.FCS(file_path, dataset = 2) #selecting 3.0 file!
    }
  }
}
```

During reading of files it was seen that not all column names were the same. They were displayed in either of two formats below:

```         
[1] "FS-H"   "FS-A"   "SS-H"   "SS-A"   "FL1-A"  "FL2-A"  "FL3-A"  "FL4-A"  "FL5-A"  "FL6-A"  "FL7-A"  "FL8-A"  "FL9-A"  "FL10-A" "TIME" 
```

```         
 [1] "FS INT LIN"   "SS INT LIN"   "FL1 INT LOG"  "FL2 INT LOG"  "FL3 INT LOG"  "FL4 INT LOG"  "FL5 INT LOG"  "FL6 INT LOG"  "FL7 INT LOG"  [10] "FL8 INT LOG"  "FL9 INT LOG"  "FL10 INT LOG" "TIME"         "FS PEAK LIN"  "SS PEAK LIN" 
```

FS-H = front scatter height (peak). Possibly the same as FS PEAK LIN FS-A = front scatter area. Possibly the same as FS INT LIN.

The same is for SS.

To standardize, column names of the fluorochrome channels are standardized to one format for each access.

```{r}
fs0 <- fcs_data_list[[1]]

colnames(fs0)
```

```{r}
rename_common_channels <- function(ff) {
  standard_names <- c("FITC", "PE", "ECD", "PC5.5", "PC7", 
                      "APC", "A700", "A750", "HLA", "KO")
  
  old_names <- colnames(ff)
  new_names <- old_names

  #patterns to select fluorophore channels
  fl_int_patterns <- paste0("^FL", 1:10, " INT")
  fl_dash_a <- paste0("FL", 1:10, "-A")

  for (i in seq_along(standard_names)) {
    matched_idx <- grep(fl_int_patterns[i], old_names)
    if (length(matched_idx) == 0) {
      matched_idx <- which(old_names %in% fl_dash_a[i])
    }
    if (length(matched_idx) > 0) {
      new_names[matched_idx[1]] <- standard_names[i]
    }
  }

  #Renaming scatter channels
  scatter_renames <- list(
    "FS INT LIN"   = "FS-A",
    "FS PEAK LIN"  = "FS-H",
    "SS INT LIN"   = "SS-A",
    "SS PEAK LIN"  = "SS-H"
  )
  
  for (original in names(scatter_renames)) {
    idx <- which(old_names == original)
    if (length(idx) > 0) {
      new_names[idx] <- scatter_renames[[original]]
    }
  }

  colnames(ff@exprs) <- new_names
  colnames(ff) <- new_names
  return(ff)
}

renamed_fcs_list <- lapply(fcs_data_list, rename_common_channels)
```

```{r}
fs1 <- renamed_fcs_list[[1]]

colnames(fs1)
```

Saving renamed files on pc:

```{r}
output_dir <- normalizePath("D:/Internship/data/renamed full dataset", mustWork = FALSE)
dir.create(output_dir, showWarnings = FALSE)

for (file_name in names(renamed_fcs_list)) {
  file_path <- file.path(output_dir, paste0(file_name, ".fcs"))
  write.FCS(renamed_fcs_list[[file_name]], filename = file_path)
}

```

## STEP 1: MANUAL COMPENSATION

Compensation can be done automatically or manually. For this, a **Spillover Spreading Matrix (SSM)** needs to be made. This matrix demonstrates fluorescence spectrum interactions. This compensation of flow cytometry data is essential as it corrects for the overlap of fluorescent signals between different channels.

NOTE: make sure compensation matrix is in fractions and NOT percentages!!

```{r}
library(readxl)

comp_matrix <- read_excel("D:/Internship/spillover_matrix.xlsx")

#Renaming row+columns and converting to num matrix.
comp_mat <- as.matrix(comp_matrix[, -c(1, 2)])
rownames(comp_mat) <- comp_matrix[[1]]
comp_mat <- comp_mat[-1, ]
comp_mat <- apply(comp_mat, 2, as.numeric)

fcs_data_list_comp <- lapply(renamed_fcs_list, function(ff) {
  compensate(ff, comp_mat)
})
```

CHECKING IF COMPENSATION WAS DONE CORRECTLY

```{r}
library(flowCore)
library(ggplot2)
library(ggcyto)

ff_comp <- fcs_data_list_comp[[1]]
ff <- renamed_fcs_list[[1]]

autoplot(ff, x = "PE", y = "FITC", bins = 200)
autoplot(ff_comp, x = "PE", y = "FITC", bins = 200)

```

## STEP 3: QUALITY CHECK USING flowAI

flowAI is used to remove events having anomalous values when looking at three aspect of a flow cytometry analysis:

1.  **flow rate**: Checks whether cells are passin through the flow cytometer at an appropriate rate. Anomalies could be due to issues like clumping of cells, clogging or incorrect flow rate settings. A high percentages suggests that cells may be analyzed under suboptimal flow conditions.

    -   Uses *generalized ESD* to detect outliers (see .ppt for further elaboration

2.  **signal acquisition**: accounts for fluorescence and scatter signal of cells. Anomalies can arise due to inadequate staining, photobleaching etc. A substantial proportion of cells with anomalous signal acquisition can lead to inaccurate fluorescence intensity measurements, affecting the interpretation of the data.

    \- Uses *Binary Segmentation* to check for changepoints and remove instable regions

3.  **dynamic range**: Evaluates whether intensities of cells fall within detectable range of cytometer. Cells outside this range can either be too dim (below detection limit) or too bright (causing signal saturation), both of which can skew data interpretation.

    -   Filter out all measurements above hard upper limit and removes all negative scatter values. For fluorescent channels, it removed outliers of negative range.

several arguments can be changed within flow_auto_qc to improve quality control results. Moreover, remove_from can be used to perform partial quality control on only one or two of the above mentioned properties.

The suggestion is to run automatic method first with default settings, if results are not satisfying, we can modify arguments.

```{r}
warnings()

#loop through all .lmd files and perform quality control
for (i in 1:length(fcs_data_list_comp)) {
  proceed_flag <- TRUE

  flow_frame <- fcs_data_list_comp[[i]]
  tryCatch({
    cleaned_fcs_data <- flow_auto_qc(flow_frame)
  }, error = function(e) {
    cat("Error in flow_auto_qc: ", as.character(e$message), "\n")
    proceed_flag <- FALSE  # Set flag to not proceed
  })
  
  if (proceed_flag) {
    cleaned_file_name <- paste0("Cleaned_", fcs_files[i])
    cleaned_file_path <- file.path(cleaned_fcs_dir, cleaned_file_name)
  
    tryCatch({
      write.FCS(cleaned_fcs_data, cleaned_file_path)
    }, error = function(e) {
      cat("Error in write.FCS: ", as.character(e$message), "\n")
    })
    
    # Display a message to indicate progress
    cat("Saved cleaned FCS file to:", cleaned_file_path, "\n")
  }
}

```

## **STEP 4: TRANSFORMATION**

Compensation corrects for spectral overlap between different fluorochromes, but it doesn't address the issue of data distribution. Flow cytometry data often exhibits positively skewed distribution. Transformations like log or biexponential (logicle) are used to convert this skewed data into a more normally distributed form. Which type of scaling should I use?

```{r}

```

```{r}

```

`{c("SSC-A", "FITC-A", "PE-A", "PerCP-Cy5.5-A", "PE-Cy7-A", "APC-A", "APC-R700-A")}`

Here we perform the removal of margin events and also the compensation is done. - Compensation is done to correct for spillover - removal of margin events, because these

```{r}
channels_of_interest <- GetChannels(object = fcs1, markers = markers_of_interest, exact = FALSE)

ff_m <- PeacoQC::RemoveMargins(fcs1, markers_of_interest)
ff_c <- compensate(ff_m, spillover(fcs1)$`$SPILLOVER`) #spillover(fcs1) extracts the spillover matrix from the metadata of the file.
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
